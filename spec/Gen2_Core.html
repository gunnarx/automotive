<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <title>Gen2 - Core</title>
    <script 
      src='https://www.w3.org/Tools/respec/respec-w3c-common' 
      class='remove'></script>
    <script type="text/javascript" src="plantuml/jquery.js"></script>
    <script type="text/javascript" src="plantuml/jquery_plantuml.js"></script>
    <script type="text/javascript" src="plantuml/rawdeflate.js"></script>	 
    <script class='remove'>
      var respecConfig = {
        specStatus: "ED",
        editors: [{
          name: "Ulf Bjorkengren",
          company: "Geotab",
          companyURL: "https://www.geotab.com"
        },
        {
          name: "Ulf Bjorkengren",
          company: "Volvo Cars",
          companyURL: "https://www.volvocars.com/intl"
        },
        {
          name: "Patrick LÃ¼nnemann",
          company: "Volkswagen Group",
          companyURL: "https://www.volkswagenag.com",
          w3cid: 95844
        }],
        edDraftURI: "https://github.com/w3c/automotive/blob/gh-pages/spec/Gen2_Core.html",
        shortName: "Gen2-core",
        localBiblio: {
          "SemVer": {
            title: "Semantic Versioning 2.0.0",
            href: "https://semver.org/spec/v2.0.0.html",
            status: "published",
            publisher: "Tom Preston-Werner"
          }
        }
      };
    </script>
  </head>
  <body>
    <section id='abstract'>
      <p>
        This document, the Gen2 core specification, describes the Gen2 messaging layer. 
        The companion specifications for the Gen2 transport protocols detail the mapping of the messaging layer to selected transports.
        The ontologies based on the Gen2 core specification are defined in documents for each specific domain
        (e.g. navigation, media, vehicle data). 
      </p>
    </section>
    <section id='sotd'></section>

    <section id="introduction">
      <h2>Introduction</h2>
      <p>
        This document describes the messaging API for Gen2 protocol. 
        This includes the messaging layer and set of rules for structuring data.
        The separation between payload encoding (transport) and messaging API (core) improves adaptability. 
        Extending and describing multiple transport protocols becomes possible.
      </p>     
      <p>
        The messages are exchanged between a <a>service</a> implementation holding the representation of data 
        and a <a>client</a> using the data.
        A <dfn>service</dfn> is an entity that manages and offers access to data.
        A <dfn>client</dfn> is an entity that works with data managed by a service.
      </p>
      <p>
        The Gen2 messaging layer uses a RESTful design for all methods exchanged via the interface (<a href="#interface"></a>).
      </p>
      <p>
        The Gen2 data structuring rules (<a href="#generic-data-model"></a>) are the same through all transport protocols.
        The basis for structuring data hold by a <a>service</a> is a tree.
      </p>
    </section>

    <section id="conformance"></section>
    <section id="terms">
      <h2>Terminology</h2>
      <p>The acronym 'Gen2' is used to refer to this document, the second generation specification. The acronym 'VSS' is used to refer to the 'Vehicle Signal Specification' which is defined by the GENIVI Alliance. The term 'WebSocket' when used in this document, is as defined in the W3C WebSocket API and the WebSocket Protocol.</p>
    </section>
    <section data-dfn-for="data-model">
      <h2>Data model</h2>
      <p>
        The basic data model that can be accessed with this interface is a tree-like logical taxonomy.
		It is represented by a directed acyclic graph.
      </p>
      <p>
        It fully supports the <a href="https://github.com/GENIVI/vehicle_signal_specification">GENIVI's Vehicle Signal Specification</a> (VSS) 
        which is recommended by the W3C [[vehicle-information-service]].
        This description gives the template, the rough outlines, out of which parts an ontology can be build.
      </p>
      <p>
		This <a href="#tree-example">example</a> shows that major vehicle structures (e.g. body, engine) are near the top of the tree and the logical assemblies and components that comprise them, are defined as their child nodes.
		Each of the child nodes in the tree is further decomposed into its logical constituents, 
		and the process is repeated until leafs are reached.
      </p>
      <p>
        A node in the tree can have one of two types.
        Leafs in the tree are <a>values</a>. 
        The path to a leaf is built by <a>branches</a>.
      </p>
      <p>
        A <dfn>schema</dfn> for a <a>branch</a> describes the structure of the <a>branch</a> itself 
        and the available child <a>branches</a> 
        and the optional and mandatory <a>values</a>.
        <div class="issue" title="schema definition">How should a schema look like? More information needed (YAML?, JSON?)</div>
      </p>
    <figure id="tree-example" class="example">
			<img uml='
			@startuml 
				skinparam component {
					BorderColor Black
					FontSize 16
					
					BackgroundColor<<branch>> MediumSeaGreen
					FontColor<<branch>> White
					
					BackgroundColor<<rbranch>> Red
					FontColor<<rbranch>> White
					
					BackgroundColor<<attribute>> Yellow
					FontColor<<attribute>> Black
					
					BackgroundColor<<sensor>> CornflowerBlue
					FontColor<<sensor>> White
					
					BackgroundColor<<actuator>> DarkGrey
					FontColor<<actuator>> White
					
					BackgroundColor<<element>> LightCoral
					FontColor<<element>> White				
				}
				[VSS-Root] -- [Media]
				[VSS-Root] -- [Car]
				[VSS-Root] -- [Private]
				[VSS-Root]<<branch>>
				[Media]<<branch>>
				[Private]<<branch>>
				[Car]<<branch>>
				
				[Media] -- [Collections]
				[Collections] .. [30321564123]
				[Collections]<<rbranch>>
				[30321564123]<<element>>
				
				[Car] -- [Engine]
				[Car] -- [Body]
				[Engine]<<branch>>
				[Body]<<branch>>
				
				[Engine] -- [RPM]
				[Engine] -- [Speed]
				[Engine] -- [Fueltype]
				[RPM]<<sensor>>
				[Speed]<<sensor>>
				[Fueltype]<<attribute>>
				
				[Body] -- [Mirror]
				[Body] -- [Door]
				[Body] -- [Weight]
				[Mirror]<<branch>>
				[Door]<<branch>>
				[Weight]<<attribute>>
				
				[Door] -- [&nbsp;...&nbsp;]
				[&nbsp;...&nbsp;]<<branch>>
				
				[Mirror] -- [Left]
				[Left] -- [Heated]
				[Left] -- [Dimmed]
				[Left] -- [Fold]
				[Left]<<branch>>
				[Right]<<branch>>
				[Heated]<<sensor>>
				[Dimmed]<<sensor>>
				[Fold]<<actuator>>
				
				[Mirror] -- [Right]
				[Right] -- [ ... ]
				[ ... ]<<branch>>
				
			@enduml
			'>
        <figcaption>Diagram showing an example tree.</figcaption>
      </figure>
	    <section data-dfn-for="tree-elements">
        <h2>Tree elements</h2>
        <section data-dfn-for="sensor">
          <h3><dfn>sensor</dfn></h3>
          <p>A leaf that describes non-static read-only signal.</p>
        </section>
        <section data-dfn-for="attribute">
          <h3><dfn>attribute</dfn></h3>
          <p>A leaf that describes static read-only value.</p>
        </section>
        <section data-dfn-for="stream">
          <h3><dfn>stream</dfn></h3>
          <p>A leaf that references a data stream, e.g. a video stream.</p>
        </section>		
        <section data-dfn-for="actuator">
          <h3><dfn>actuator</dfn></h3>
          <p>A leaf the same as <a>sensor</a> which additionaly can be changed.</p>
        </section>
        <section data-dfn-for="branch">
          <h3><dfn>branch</dfn></h3>
          <p>
          A <a>branch</a> MUST host one or more children of any node type except <a>element</a>. 
          </p>
          <div class="issue">to be described more</div>
        </section>		
        <section data-dfn-for="rbranch">
          <h3><dfn>rbranch</dfn></h3>
          <p>
          A node under an <a>rbranch</a> MUST be an <a>element</a>.
          </p>
          <div class="issue">to be described more</div>
        </section>
        <section data-dfn-for="element">
          <h3><dfn>element</dfn></h3>
          <div class="issue">to be described</div>
        </section>
      </section>

      <section data-dfn-for="address">
        <h2>Addressing</h2>
        <p>Addressing of elements is done using URIs as defined in [[RFC3986]].</p>
        <blockquote><a>scheme</a>:<a>authority</a>/<a>path</a></blockquote>
        <p>The <dfn>scheme</dfn> describes the protocol to use to reach the addressed element.
          The <dfn>authority</dfn> describes where to reach the service holding and managing the data representation.
          Scheme and authority are defined within the protocol adaptation.</p>
        <p><dfn>Path</dfn> describes the location of a specific data representation within a service.
          It is the path through the tree, the data representation, implemented by the service.</p>
      </section>
      
      <section data-dfn-for="data-types">
        <h2>Data Types</h2>

        <section data-dfn-for="number">
          <h3><dfn>Number</dfn></h3>
          <p>
          <a>Number</a> is used to represent numbers. 
          This includes all signed and unsigned integer values and floats.
          To allow for memory allocation restrictions MUST be given.
          Restrictions MUST be expressed by using min, max and precision.
          Min MUST describe the lowest possible value.
          Min MUST be defined as base to the power of min (i.e. b^min).
          Max MUST describe the highest possible value.
          Min MUST be defined as base to the power of max with an optional -1 (i.e. b^max - 1).
          Precision MUST describes the smallest changeable amount in the value.
          Precision MUST be defined as base to the power of precision (i.e. b^n). 
          A <a>schema</a> MAY define the restrictions by using predefined restrictions.
          <table class="def">
            <tr><th>name</th>
              <th>description</th>
              <th>min</th>
              <th>max</th>
              <th>resolution</th></tr>
            <tr><th><dfn>UInt8</dfn></th>
              <td>unsigned 8-bit integer</td>
              <td>0</td>
              <td>255</td>
              <td></td></tr>
            <tr><th><dfn>Int8</dfn></th>
              <td>signed 8-bit integer</td>
              <td>-128</td>
              <td>127</td>
              <td></td></tr>
            <tr><th><dfn>UInt16</dfn></th>
              <td>unsigned 16-bit integer</td>
              <td>0</td>
              <td>65535</td>
              <td></td></tr>
            <tr><th><dfn>Int16</dfn></th>
              <td>signed 16-bit integer</td>
              <td>-32768</td>
              <td>32767</td>
              <td></td></tr>
            <tr><th><dfn>UInt32</dfn></th>
              <td>unsigned 32-bit integer</td>
              <td>0</td>
              <td>4294967295</td>
              <td></td></tr>
            <tr><th><dfn>Int32</dfn></th>
              <td>signed 32-bit integer</td>
              <td>-2147483648</td>
              <td>2147483647</td>
              <td></td></tr>
            <tr><th><dfn>UInt64</dfn></th>
              <td>unsigned 64-bit integer</td>
              <td>0</td>
              <td>2^64-1</td>
              <td></td></tr>
            <tr><th><dfn>Int64</dfn></th>
              <td>signed 64-bit integer</td>
              <td>2^63</td>
              <td>2^63-1</td>
              <td></td></tr>
            <tr><th><dfn>Float</dfn></th>
              <td>floating point number</td>
              <td>-3.4e -38</td>
              <td>3.4e 38</td>
              <td></td></tr>
            <tr><th><dfn>Double</dfn></th>
              <td>double precision floating point number</td>
              <td>-1.7e -300</td>
              <td>1.7e 300</td>
              <td></td></tr>
            <tr><th><dfn></dfn></th>
              <td></td>
              <td></td>
              <td></td>
              <td></td></tr>
          </table>
          </p>
        </section>
        
        <section data-dfn-for="Boolean">
          <h3><dfn>Boolean</dfn></h3>
          <p>Simple true or false</p>
        </section>
        
        <section data-dfn-for="String">
          <h3><dfn>String</dfn></h3>
          <p>
          <a>String</a> is used to represent sequence of characters.
          To allow for memory allocation restrictions MUST be given.
          Restrictions MUST include a maximum string length.
          Restrictions MAY include a character set.
          If no character set is given unicode MUST be assumed.
          Restrictions MAY include a regular expression.
          <span class="issue">which regex style?</span>
          A <a>schema</a> MAY define the restrictions by using predefined restrictions.
          Protocol specific implementations MAY use optimized versions to transfer values with predefined restrictions.
          <table class="def">
            <tr><th>name</th>
              <th>description</th>
              <th>max</th>
              <th>example</th>
              <th>RegEx</th></tr>
            <tr><th><dfn>date-time</dfn></th>
              <td>date-time (based on RFC3339 5.6) detailed fraction</td>
              <td>29</td>
              <td class="example">2005-11-12T12:01:42.123+01:00</td>
              <td><code>^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(\.\d{3})?((Z|(\+|\-)\d{2}:\d{2}))$</code></td></tr>
            <tr><th><dfn>time</dfn></th>
              <td>time (based on RFC3339 5.6) detailed fraction</td>
              <td>18</td>
              <td class="example">12:01:42.123+01:00</td>
              <td><code>^\d{2}:\d{2}:\d{2}(\.\d{3})?((Z|(\+|\-)\d{2}:\d{2}))$</code></td></tr>
            <tr><th><dfn>date</dfn></th>
              <td>date (RFC3339 5.6)</td>
              <td>10</td>
              <td class="example">2005-11-12</td>
              <td><code>^\d{4}-\d{2}-\d{2}$</code></td></tr>
            <tr><th><dfn></dfn></th>
              <td></td>
              <td></td>
              <td class="example"></td>
              <td><code></code></td></tr>
          </table>
          </p>
        </section>

        <section data-dfn-for="ByteArray">
          <h3><dfn>ByteArray</dfn></h3>
          <p>
            <a>ByteArray</a>, also known as a blob, is an array of bytes of not nearer specified data.
            To allow for memory allocation restrictions MUST be given.
            Restrictions MUST include a maximum number of bytes.
          </p>
        </section>

      </section>
        <section data-dfn-for="Foo">
          <h2>Service discovery</h2>
          <p>The client MAY request that the server returns the VSS tree content. The client is able to request metadata from any point in the signal tree, such that only the metadata for the nodes within the given branch of the tree is returned. For example, only metadata for the chassis branch of the VSS tree is returned when the chassis path is specified. If the path is set to the VSS root, the response contains the metadata for the entire tree. If the server is able to satisfy the request it SHALL return a Response message. If an error occurs the server SHALL return an ErrorResponse message. The key data components of these messagess are defined below:</p>
          <ul>  
            <li>Request message parameters:</li>
            <ul>  
              <li>Path: The address to one or more nodes in the VSS tree, followed by the path segment "$spec".</li>
            </ul>  
            <li>Response message parameters:</li>
            <ul>  
              <li>Metadata: The content of the VSS tree where the root is specified by the path.</li>
              <li>Timestamp: A timestamp associated with the request.</li>
            </ul>  
            <li>ErrorResponse message parameters: </li>
            <ul>  
              <li>Error: Information describing the error reason.</li>
              <li>Timestamp: A timestamp associated with the failed request.</li>
            </ul>  
          </ul>  
        </section>
    </section>
	
    <section id="filter-mechanisms">
      <h2>Filtering</h2>
	  <p>
	  This section describes how to build the queries to filter for specific parts of the data representation.
	  </p> 
	  <p>A <dfn>query</dfn> is a description to taylor and filter the data resulting of a <a>read</a>.</p>
	  <p>The <a>query</a> can be given with the request from a client to a service additionally to the <a>path</a> to get a <a>content</a> response.
	  The <a>query</a> describes certain rules that filter the <a>content</a> response. 
	  <ul>
			<li>path: describing the part of the tree that shall be filtered in</li>
			<li>rules: these have to match in the nodes for the node to be part of the <a>content</a> response.</li>
	  </ul>
		</p>
		<div class="example">
		<h3>Example</h3>
			<p>
			All open doors shall be given. The tree looks as follows:
			<blockquote>
				<ul><li>/vehicle/cabin
					<ul><li>/Row1
						<ul><li>/Left
							<ul><li>/Door
								<ul>
									<li>isLocked: true</li>
									<li>open: false</li>
								</ul>
							</li></ul>
						</li></ul>
						<ul><li>/Right
							<ul><li>/Door
								<ul>
									<li>isLocked: false</li>
									<li>open: true</li>
								</ul>
							</li></ul>
						</li></ul>
					</li></ul>
					<ul><li>/Row2
						<ul><li>/Left
							<ul><li>/Door
								<ul>
									<li>isLocked: false</li>
									<li>open: false</li>
								</ul>
							</li></ul>
						</li></ul>
						<ul><li>/Right
							<ul><li>/Door
								<ul>
									<li>isLocked: true</li>
									<li>open: true</li>
								</ul>
							</li></ul>
						</li></ul>
					</li></ul>
				</li></ul>
			</blockquote>
			</p>
			<p>
			The <a>path</a> that shall be inspected is "/vehicle/cabin". <br>
			The <a>rule</a> is that "/vehicle/cabin/*/*/Door/isLocked" shall be "true".<br>
			</p>
			<p>
			The list in the <a>content</a> response would look like this:
			<blockquote>
			<ul>
			<li>/vehicle/cabin/Row1/Left/Door</li>
				<ul>
					<li>isLocked: true</li>
					<li>open: false</li>
				</ul>
			<li>/vehicle/cabin/Row2/Right/Door</li>
				<ul>
					<li>isLocked: true</li>
					<li>open: true</li>
				</ul>
			</ul>
			</blockquote>
			</p>
		</div>
     <section data-dfn-for="rules">
        <h3>Rules</h2>
		<p>
		A <dfn>rule</dfn> is an expression that describes a characteristic of nodes that shall be returned by a <a>query</a>.
		<a>Rules</a> are applied to a leaf and describe a desired attribute of a node.
		All <a>rules</a> MUST return either FALSE or TRUE.
		</p>
		<p>
		These are the <a>rules</a> that are known to check to be used in a <a>query</a> to filter <a>content</a> responses.
		
		<table border="1">
			<tr><th>name</th><th><a>input type</a></th><th>Description</th><th>Example</th></tr>
			<tr>
				<th><dfn>true</dfn></th>
				<td><a>boolean</a></td>
				<td>matches if the data value is true</td>
				<td>true(isLocked)</td>
			</tr>
			<tr>
				<th><dfn>false</dfn></th>
				<td><a>boolean</a></td>
				<td>matches if the data value is false</td>
				<td>false(isLocked)</td>
			</tr>
			<tr>
				<th><dfn>contains</dfn></th>
				<td><a>string</a></td>
				<td>matches if a given string is contained in another one</td>
				<td>contains(name, "blue")</td>
			</tr>
			<tr>
				<th><dfn>equal</dfn></th>
				<td>(<a>string</a>|<a>boolean</a>|<a>number</a>)</td>
				<td>matches if a value is equal to a given value</td>
				<td>equal(name, "Red Door")</td>
			</tr>
			<tr>
				<th><dfn>greaterThan</dfn></th>
				<td><a>number</a></td>
				<td>matches if a given number is greater than the value</td>
				<td>greaterThan(windowPosition, 0.2)</td>
			</tr>
			<tr>
				<th><dfn>smallerThan</dfn></th>
				<td><a>number</a></td>
				<td>matches if a given number is smaller than the value</td>
				<td>smallerThan(windowPosition, 0.2)</td>
			</tr>
			<tr>
				<th><dfn>greaterThanEqual</dfn></th>
				<td><a>number</a></td>
				<td>matches if a given number is greater than the value or equal to the value</td>
				<td>greaterThan(windowPosition, 0.2)</td>
			</tr>
			<tr>
				<th><dfn>smallerThanEqual</dfn></th>
				<td><a>number</a></td>
				<td>matches if a given number is smaller than the value or equal to the value</td>
				<td>smallerThan(windowPosition, 0.2)</td>
			</tr>
		</table>
		</p>
		<p>
		It MUST be possible to combine several <a>rules</a> to one greater <a>rule</a>. This is possible with the following operators.
		
		<table border="1">
			<tr>
				<th><dfn>not</dfn></th>
				<td><a>rule</a></td>
				<td>negates the return of a rule</td>
				<td>not(true(isLocked))</td>
			</tr>
			<tr>
				<th><dfn>and</dfn></th>
				<td><a>rule</a>,<a>rule</a></td>
				<td>returns true if both of the <a>rules</a> evaluates true</td>
				<td>and(ruleA,ruleB)</td>
			</tr>
			<tr>
				<th><dfn>or</dfn></th>
				<td><a>rule</a>,<a>rule</a></td>
				<td>returns true if one of the <a>rules</a> evaluates true</td>
				<td>or(ruleA,ruleB)</td>
			</tr>
		</table>
		</p>
      </section>
    </section>
 
    <section id="authorization">
<h2 id="-a-name-userauth-a-user-authentication-and-authorization"><a id="userauth"></a>Authentication and Authorization</h2>
<p>In order to secure API access and to guarantee delivery of authorized content only, a token-based mechanism (cmp. <a href="https://tools.ietf.org/html/rfc6749">OAuth 2.0 - RFC6749</a>, <a href="https://tools.ietf.org/html/rfc7519">JWT - RFC7519</a>, <a href="https://tools.ietf.org/html/rfc7523">JWT OAuth Profile - RFC7523</a>) is used. OAuth grants an application access to protected data only for specific use cases (scopes) and often for a limited amount of time.</p>
<p>Details on how the JWT tokens will be sent by the clients are described in the TRANSPORT specification.</p>
    <section id="jwt">
<h3 id="-a-name-auth_jwt-a-jwt-based-access-token"><a id="auth_JWT"></a> JWT-based access token</h3>
<p>JSON Web Token (JWT) is an open standard <a href="https://tools.ietf.org/html/rfc7519">RFC 7519</a> that defines a compact and <strong>self-contained</strong> way for transmitting authenticated information between parties as a JSON object. This information can be verified and trusted because it is digitally signed. JWTs can generally be signed using a public/private key pair using RSA or ECC.</p>
<p>For the application to the protocol, the token issuer (<code>iss</code> claim) has to provide access to its public key (<code>sigurl</code> claim) for token verification. At the same time, the public key references in the sigurl claim must be authenticated using appropriate PKI mechanisms. Alternatively, the public key used for verifying tokens may be exchanged (and updated) via a separate, authenticated channel.</p>
<p>The payload of a JWT-based access token contains all the required information like the scope (<code>scp</code> claim), avoiding the need to query the auth server more than once, thus they are called <strong>self-contained</strong>.</p>
<p>Token verification is crucial and MUST be implemented by all services handling sensitive information.</p>
<h5 id="expiry">Expiry</h5>
<p>JWT-based access tokens are stateless keys to information that needs to be protected. Therefore a token has to be <em>revokable</em>. As the underlying concept of self-containing tokens does not allow revocation by a central component on a request by request basis, JWT-based access tokens shall generally expire quickly. This narrows down the possible time window for using a token without permission. After a token expires, the client is forced to obtain a fresh access token and can be denied access to the service at this point in time. Additionally, if narrow time constraints must be met, the authorization server must offer a token whitelist - listing only token meta information - every service can subscribe to based on the JWT access token&#39;s identifier (<code>jti</code> claim).</p>
<h5 id="identification">Identification</h5>
<p>Every JWT shall contain a <code>jti</code> claim in its header to allow for blacklisting, revocation notification and one time use.</p>
<h5 id="trust-decisions">Trust decisions</h5>
<p>The contents of a JWT cannot be relied upon in a trust decision unless its contents have been cryptographically secured and bound to the context necessary for the trust decision. In particular, the key(s) used to sign and/or encrypt the JWT will typically be under the control of the party identified as the issuer of the JWT. Unsigned JWT-based access tokens MUST fail in their verification.</p>
<p>Every JWT shall contain an <code>iss</code> (issuer) claim in its header to identify the principal that issued the token by an identifier known to the party attempting to verify the token.</p>          </section>



    <section data-dfn-for="authorization-process">
<h3 id="authorization-process-security-recommendation-">Authorization Process &amp; Security (recommendation)</h3>
<p>Applying the token mechanisms discussed earlier in this chapter allows authorization based on these tokens. This allows a central token service to enforce a policy based on flexible scopes that may or may not group several services into logical groups. In the following, we describe a reference authorization architecture based on JWTs. Using JWTs allows a server to evaluate a request in isolation, without having to query a central component repeatedly. However, to achieve timely revocation of service access without having the client obtain new tokens frequently, we propose to implement a revocation notification mechanism (see below).</p>
<div class="issue">We probably should present a figure defining the entities in this ecosystem - the server(s) managing the services, the token provisioning server, and the token validation server. This chapter does currently not describe this partitioning.</div>
<h4 id="security-by-osi-level">Security by OSI Level</h4>
<p>On a basic level, the system has to implement specific security related mechanisms on different layers of the network stack:</p>
<table>
<thead>
<tr>
<th>OSI</th>
<th></th>
<th>Mechanism</th>
<th>Protocol(s)</th>
</tr>
</thead>
<tbody>
<tr>
<td>7</td>
<td>Application</td>
<td>Token-based Authorization</td>
<td>JWT/OAuth2</td>
</tr>
<tr>
<td>6</td>
<td>Presentation</td>
<td></td>
<td></td>
</tr>
<tr>
<td>5</td>
<td>Session</td>
<td>Authentication + Encryption</td>
<td>TLS</td>
</tr>
<tr>
<td>4</td>
<td>Transport</td>
<td>Firewall</td>
<td>TCP</td>
</tr>
<tr>
<td>3</td>
<td>Network</td>
<td>Firewall</td>
<td>IP</td>
</tr>
<tr>
<td>2</td>
<td>Data-Link</td>
<td></td>
<td></td>
</tr>
<tr>
<td>1</td>
<td>Physical</td>
<td></td><td></td>
</tr>
</tbody>
</table>
<h4 id="firewall">Firewall</h4>
<p>A firewall shall ONLY let the traffic pass it is configured for. All other ports shall be blocked by default.</p>
<h4 id="transport-layer-security">Transport Layer Security</h4>
<p>To secure the transfer of messages and tokens, transport layer security shall be established through the TLS protocol. For more detailed requirements on the required TLS version and cipher suites see Section #ref. Whether a concrete interface needs to be encrypted is subject of the security specification. However, all requests that include tokens MUST be made through an encrypted TLS channel.
All necessary measures to allow TLS must be implemented, such as reliable time and secure certificate storage on the device using the certificate to authenticate. In case of mutual authentication, the client also needs to have appropriate key material.</p>
<h5 id="communication-types">Communication types</h5>
<p>There are two different types of communication â <code>public</code> and <code>confidential</code>. The differentiation between these two types of communication is rather a project oriented than a security oriented. Communication is considered <code>confidential</code> when two trusted devices communicate with each other, e.g., the communication between two ECUs that are under full control (quality, security, testing etc.) of the vendor is considered <code>confidential</code> while the communication with at least one 3rd party client is considered <code>public</code> (e.g. cloud based client, smartphone client,â¦).</p>
<p>An internal communication is between a service/server and a - in an OAuth sense - <strong>confidential</strong> <code>confidential</code> client (i.e., one that can be securely provisioned with cryptographic key material). Internal communication will usually rely on a mutually authenticated TLS channel to establish a client identity for issuing tokens. See <a href="https://tools.ietf.org/html/rfc6749#section-2.1">OAuth 2.0 - RFC6749 Section 2.1</a> for details.</p>
<p>Conversely, <code>public</code> communication occurs between a service/server and a - in the OAuth sense - <strong>public</strong> client. A <code>public</code> client cannot have reliable key material and can therefore not be authenticated directly. Instead, the protocol relies on a trusted system to attest the authenticity of a user identity on that client. The client then forwards a proof of authentication (e.g. an Authorization Grant Token cf. <a href="https://tools.ietf.org/html/rfc7523">RFC7523</a>) from the trusted system to the in-vehicle authorization server to attest the clients identity.</p>
<h6 id="use-cases">Use Cases</h6>
<p>For the different use case for API usage, different cipher suites are recommended:</p>
<table>
<thead>
<tr>
<th>Communication between</th>
<th>Cipher Suite</th>
</tr>
</thead>
<tbody>
<tr>
<td>vehicle internal clients with encryption, with token-based authentication (default - internal)</td>
<td>TLS_PSK_WITH_AES_128_CBC_SHA256</td>
</tr>
<tr>
<td>vehicle internal clients with encryption, with TLS-based authentication (e.g. certificate) (mutual auth with certificate pinning)</td>
<td>TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256 with ECC: secp256r1 (prime256v1)</td>
</tr>
<tr>
<td>vehicle internal clients without encryption, with authentication (might be decided to be used on per-service basis)</td>
<td>TLS_PSK_WITH_NULL_SHA256</td>
</tr>
<tr>
<td>vehicle and vehicle external clients with encryption, with token based authentication (e.g. certificate) (default - external)</td>
<td>TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256 with ECC: secp256r1 (prime256v1)</td>
</tr>
<tr>
<td>vehicle and vehicle external clients without encryption or without authentication</td>
<td>-</td>
</tr>
</tbody>
</table>
<h5 id="authorization-grant-token-agt-">Authorization Grant Token (AGT)</h5>
<p>The <code>AGT</code> is a JWT (<a href="https://jwt.io">https://jwt.io</a>, <a href="https://tools.ietf.org/html/rfc7519">https://tools.ietf.org/html/rfc7519</a>) Token, profiled according to RFC7523 (JWT OAuth 2.0 Client Authorization Grant profile). The token MUST be signed by a trusted entity. The auth server uses the AGT to establish a client user identity (if any). An AGT shall only be valid for presentation at a particular vehicle&#39;s authorization server and shall thus contain a vehicle identifier (e.g., the VIN). The auth server must have access to an authentic public key to verify the AGT signature. The auth server must also be able to obtain updated public key material from the backend for AGT validation.</p>
<p>AGTs shall only be valid for a limited amount of time (several days). Checking revocation is impractical for the auth server as limited connectivity would negatively impact the user experience when attempting to access services in a vehicle. Instead, the client shall fetch new AGTs when the existing copies are about to expire. Under adversarial conditions, this would mean that an attacker can abuse e. g. a stolen portable device to access services in the name of the original user. This issue could however be mitigated by the portable device locking mechanisms as well as the ability to remove a user identity from a vehicle remotely using other frontends. Exfiltrating an AGT from a device or the communication channel would require a much higher effort, if platform and transport security are intact.</p>
<p>The AGT shall contain at least the following claims:</p>
<ul>
<li>Issuer (iss)</li>
<li>Issuing date (iat)</li>
<li>Expiration Time (exp)</li>
<li>JWT identifier (jti)</li>
<li>Client User ID being attested (uid)</li>
<li>Audience (aud)</li>
</ul>
<h6 id="creating-the-token">Creating the token</h6>
<p>The client requests the AGT from the backend, specifying a target audience (a VIN), alongside backend authentication information (e.g., a backend access token). The backend system shall create and sign the desired AGT only if the user authentication is or was previously successful. Additional authorization checks MAY occur in the backend system. The signature MUST only be applied when all checks are positive. After this step a signed AGT is available for presentation to the auth server.</p>
<h6 id="token-header">Token Header</h6>
<p>Claims in the AGT header are â find the claim key for JSON in parentheses:</p>
<p><strong>Issuer (iss)</strong></p>
<p>The <code>iss</code> (issuer) claim identifies the principal that issued the JWT. The processing of this claim is generally application specific. The &quot;iss&quot; value is a case-sensitive string containing a String or URI value. This claim is MANDATORY and allows the token consumer to select appropriate key material for validation.</p>
<p><strong>Link to public key used for signature (sigurl)</strong></p>
<p>The <code>sigurl</code> claim (signature url) contains an url pointing to the public key to be applied for token signature verification. This public key has to be assigned to and issued by a trusted source (i.e., the consumer of the token must be able to authenticate the public key obtained from the <code>sigurl</code>, for example by pinning a specific root or intermediate certificate for a certificate in the sigurl). This claim is OPTIONAL, as the auth server may obtain the necessary public key through another suitable (authenticated, updatable) channel.</p>
<p><strong>Issuing date (iat)</strong></p>
<p>The <code>iat</code> (issued at) claim identifies the time at which the JWT was issued. This claim can be used to determine the age of the JWT. Its value MUST be a unix timestamp and MUST be validated to be in the past. This claim is MANDATORY.</p>
<p><strong>Expiration time (exp)</strong></p>
<p>The <code>exp</code> (expiration time) claim identifies the expiration time on or after which the JWT MUST NOT be accepted for processing. The processing of the <code>exp</code> claim requires that a reliable time source is available and that the current date/time MUST be before the expiration date/time listed in the <code>exp</code> claim. Implementers MAY provide for some small leeway, usually no more than a few minutes, to account for clock skew. Its value MUST be a unix timestamp. This claim is MANDATORY.</p>
<p><strong>JWT identifier (jti)</strong></p>
<p>The <code>jti</code> (JWT ID) claim provides a unique identifier for the JWT. The identifier value MUST be assigned in a manner that ensures that there is a negligible probability that the same value will be accidentally assigned to a different data object. The <code>jti</code> claim can be used to prevent the JWT from being replayed. The <code>jti</code> value is a case-sensitive string, it SHALL be used to revoke a token. This claim is MANDATORY.</p>
<h6 id="token-payload">Token payload</h6>
<p>Mandatory claims in the <code>AGT</code> payload â find the claim key for JSON in parentheses:</p>
<p><strong>Username/Userid (uid)</strong></p>
<p>The <code>uid</code> (User Id) claim provides a unique identifier for the user the client is requesting authorization for. Usually the <code>uid</code> claim will hold a system-wide user identifier. The <code>uid</code> claim is used by the auth server to inform authorization decisions (e.g., whether an additional permission popup is necessary). The <code>uid</code> value is a case-sensitive string. The <code>uid</code> will be compared to the user logged in on the main unit. This claim is MANDATORY.</p>
<p><strong>Audience (aud)</strong></p>
<p>The <code>aud</code> (Audience) claim shall indicate which vehicle this AGT was issued for. Usually, the aud claim will contain a VIN. The token consumer MUST ensure that the audience string matches the expected value, i.e. that the token was issued for this vehicle.</p>
<div class="issue">The aud claim is MANDATORY??</div>
<h5 id="auth-server">Auth Server</h5>
<p>The Access-Token issuer Service (auth server) is in charge of deciding over access requests submitted by a client. The client will request access to a given scope. A scope usually comprises access to one or more services. The server will validate an access token issued by the auth server, checking - among other things - that the token carries the expected scope. Below, relevant identities, scopes, policies and how tokens are issued are described.</p>
<p>The client request for an access token shall include the following information:</p>
<ul>
<li>client ID</li>
<li>client user ID attestation (AGT), if available</li>
<li>TLS client identity, if mutual TLS was used</li>
<li>desired scope</li>
<li>human-readable identifier</li>
</ul>
<p>The auth server shall then decide whether or not to issue an access token based on this information, obtaining consent from the current vehicle user, if necessary. This process will be detailed in the following.</p>
<h6 id="types-of-identities-for-authorization-decisions">Types of Identities for Authorization decisions</h6>
<p>Several identities need to be considered for authorization decisions and therefore be used by the authorization server. These identities are listed in the following.</p>
<h6 id="client-identity">Client Identity</h6>
<p>The client requesting a service may have an identity itself. In this context, the term client usually refers to the device a piece of software is running on. The identity of this client (device) is generally only ascertainable if cryptographic key material is securely available on the device. Hence, the OAuth 2.0 standard distinguishes <strong>confidential</strong> and <strong>public</strong> clients. A confidential client is more tightly controlled in terms of software as well as hardware and can thus be securely provisioned with key material, which can be used to run cryptographic authentication protocols. In turn, a public client (e.g., a smartphone app on a smartphone without a trust store for secure certificate storage) comes with no such guarantees and is assumed to be more easily compromised by an adversary.</p>
<p>A confidential client shall be able to establish a mutually authenticated TLS channel with the auth server and the service server, providing a trusted identity, usually in the form of a certificate signed by a trusted authority. A confidential client can thus provide a proof of possession for a certain client identifier (client ID). After establishing a mutually authenticated channel with such a client, the server can be reasonably sure to be communicating with the same client as before. Confidential clients are therefore extended a client-level trust.</p>
<p>In contrast, a public client cannot provide any reliable identification information. Instead, public clients shall generate a unique identifier (UUID, client ID), for which it is very unlikely that another client chooses the same value.  The client ID is thus only a weak identifier, which shall be used with care. In most cases, public clients shall provide a user identity that is asserted by a trusted backend on top of the client ID. It is this client user identity (that must have been previously authenticated between client, user and backend) which shall be the main source of a trust decision.</p>
<p><strong>Client User Identity</strong></p>
<p>The client user identity is a user identity that has been authenticated by a trusted backend systems towards the client. The auth server may choose to make authorization decisions based on this identity, for example comparing the client user identity with the system user identity (see below). If these two identities match, the auth server might conclude that the user in the vehicle is the same as the user that is logged in on the client and therefore grant a request. For the purposes of this protocol, the client user identity shall be communicated using JWT authorization grant tokens (AGT, see above).</p>
<p><strong>System User Identity</strong></p>
<p>The system user identity corresponds to the identity of the user currently active inside the vehicle. It is assumed that this identity belongs to the user currently in charge of operating the vehicle (i.e., the driver). The system will usually have credentials to act as this user with respect to other backend systems (e.g., to access personalized navigation functionality). The system user identity shall be available to the auth server from the environment (i.e., the platform the auth server is running on, e.g., the main unit).</p>
<p>In the future, there may be situations where more than one user identity is considered active on the system (i.e., the vehicle is personalized for multiple users, including potential passengers). In this case, additional metadata about the system users (e.g., which screen belongs to their seat) may be required for making authorization decisions. This use case, however, is not covered by the current version of this specification.</p>
<div class="issue">The client/system user Id descriptions above should be extended with a cloud based client.</div>
<h6 id="scopes">Scopes</h6>
<p>When requesting access to services, the client must specify a scope it wants to get access to. A scope describes a logical set of services. This facilitates the specification of policies as well as describing the current state of authorization to users, if need be. Clients request access to a certain scope and a service expects an access token for a certain scope. Similarly, the authorization server is not concerned with particular services but just with more abstract scopes. Using scopes allows the reuse of an access token for multiple services, which reduces the burden on client-side token management as well as requests against the auth server. Additionally, scopes also allow more fine-grained access control, where one service might expect different scopes for operations of different sensitivity (e.g., read vs. write).</p>
<p>There shall be two types of scopes: <code>internal</code> scopes are granted based on client properties (e.g. client identity or client type) without user interaction; conversely, <code>user</code> scopes may be granted through user interaction, i.e. a popup asking the user to decide whether or not a certain client should be able to use certain functionality. These user-scopes shall be defined in a way that facilitates understanding of a grant decision when being presented to a user, i.e., so that the set of services grouped into the scope carries meaning to a user. Otherwise, users are not able to effectively exercise the control that is expected by the system to protect them from unwanted accesses.</p>
<p>Every client has to know which scopes to request access Ã¡ priori, i.e. the scope usually are to be known at implementation time.</p>
<p><strong>User Scopes</strong></p>
<p>As a reference, the following set of scopes shall be used to govern access:</p>
<table>
<thead>
<tr>
<th>Scope Label</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>hvacRead</td>
<td>Read heating, ventilation and AC information</td>
</tr>
<tr>
<td>hvacControl</td>
<td>Change HVAC state (e.g. set temperature, enable seat heating, etc. )</td>
</tr>
<tr>
<td>carStatusRead</td>
<td>Read state of vehicle (doors/windows open, oil temperature, etc.)</td>
</tr>
<tr>
<td>carConfigrurationRead</td>
<td>Read car-related settings (i.e. read settings found in car menu)</td>
</tr>
<tr>
<td>carConfigrurationControl</td>
<td>Modify car-related settings (i.e. modify settings found in car menu)</td>
</tr>
<tr>
<td>audioRead</td>
<td>Read audio/sound management (sources, volume, balance, etc.)</td>
</tr>
<tr>
<td>audioControl</td>
<td>Modify audio/sound settings (sources, volume, balance, etc.)</td>
</tr>
</tbody>
</table>
<div class="issue">The scope definitions needs more work.</div>
<p>New services may require the definition of additional scopes. However, the list of scopes that can be presented to the user for grating authorization must remain as low as possible to avoid user confusion.</p>
<p><strong>Internal Scopes</strong></p>
<p>Internal scopes are scopes that can only be granted to clients based on their properties (client type, client id, client user type, etc.) and <em>not</em> by user interaction. The granularity of such scopes shall be flexible and up to the implementer as well as the desired control over internal service access. They can range from one single scope for all internal services to one scope per service operation.</p>
<h6 id="policies">Policies</h6>
<p>Based on the requested scope, the client type, the client user identity, the current system user identity as well as previously granted permissions, the authorization server will search for a policy match. If a match is found, an access token matching the requested scope is issued.</p>
<p>A policy may additionally specify that user interaction is necessary to grant a certain scope. An example policy may state: &quot;If the client user identity does not match the current system user identity, display a popup asking for permission to access scope X&quot;. This decision shall be remembered, in the context of the current system user identity, by the authorization server. It is important to note that each system user identity shall be able to grant or deny permissions individually. This means that a system user A may grant permission P to client user Z, while system user B denies P to Z. Implementations must choose to grant (or deny) requested scopes indefinitely (until revocation) or for a certain (potentially user-chosen) amount of time. This choice may be made on a scope-by-scope basis.</p>
<p>On the other hand, the authorization server shall be able to deny access to certain (more sensitive) services under certain conditions. For example, only a client in the body control ECU shall be able to update the status of the vehicle&#39;s doors and windows or all write access shall be denied to public clients.</p>
<p><strong>Requesting Permission from the User</strong></p>
<p>A policy may defer an authorization decision to the current system user, as only the user currently in control of the vehicle shall be able to decide whether or not a certain client shall be able to access certain functionality.</p>
<p>There shall only be a small number of scopes (likely less than 10) that a user can ever be asked to grant for a given client. The interface presented to the user for making the authorization decision shall be presented when the client in question is making the request to access a service associated to the scope in question. The interface shall present a meaningful description of the extent of the scope to be granted. It shall also present a meaningful identifier for the client to be authorized. Lacking a reliable identifier, clients shall be allowed to provide a human-readable name when requesting access at the auth server.</p>
<p>It may be beneficial to allow the user making the authorization decision to specify additional constraints. The interface may choose to offer options to grant the permission until a certain time or event. Examples include until the permission is explicitly revoked, until the end of the current drive, for the next month, etc. Useful options should be determined from user research and must be enforced by the auth server.</p>
<p>All permission decisions shall be stored on a per-system-user basis in a consent service within the auth server. This only concerns permission decisions made by the user. Decisions made by the auth server by policy only shall not be documented in this table (as they should be stateless). The consent service shall store decisions as follows:</p>
<ul>
<li>System User ID</li>
<li>Client ID (+ human-readable name)</li>
<li>Client User ID</li>
<li>Scope</li>
<li>Decision (access/deny)</li>
<li>Expiry (e.g. driving cycle, timestamp, never)</li>
<li>JWT-ID: The ID of the token issued based on this consent</li>
</ul>
<p>This information shall also be available to the system user in order to manage permissions.</p>
<h6 id="access-token">Access token</h6>
<p>An access token is needed to access the APIs of services. These tokens are issued as JWT based on <a href="https://tools.ietf.org/html/rfc7523">RFC7523</a> (OAuth 2.0 profile for client authorization grants). The <code>accessToken</code> is issued to the client by the auth server after the policy checks described above have been successfully passed. The client then sends the token with each request where it is required. The recipient/service MUST deny any API access without a valid token being provided. The token&#39;s validity MUST be checked for each request. Additionally, after receiving a token for the first time, the service must subscribe to notifications of revocation for this token&#39;s identifier. The <code>accessToken</code> is a JWT-type token with a signature provided by the issuer. The token SHALL be as small as possible to avoid excessive communication overhead.</p>
<p><code>accessToken</code>s are strictly bound to the system user identity who granted access (if any). This means that in a single user system they are only valid for the services of the currently active system user identity.</p>
<p>AccessToken validity must begin with issuance. AccessTokens shall be issued for a certain vehicle (VIN) and system user identity (uid). Expiration may be indefinite (until revocation) or shorter, based on the configured policy or user decision. It is important to note that meaningful expiration requires a reliable source of date and time information (authenticated time).</p>
<p>If an <code>accessToken</code> is not valid anymore, all API access MUST be prohibited. On expiration or revocation, the client MUST request a new <code>accessToken</code> and satisfy the corresponding auth server policy. An appropriate status code MUST be sent as a response.</p>
<p><strong>Revocation</strong></p>
<p>The vehicle token server shall maintain a list of access token identifiers issued based on a certain user decision (see [Requesting Permission from the User] above). Once an access decision is revoked, the vehicle token server must notifiy all services consuming these access tokens of the revocation. It is the responsibility of the service to register for revocation notification of known token identifiers.</p>
<h6 id="access-token-content">Access Token Content</h6>
<ul>
<li>expiry (exp): timestamp after which this token shall be considered invalid</li>
<li>audience (aud): The type of service/protocol this token was issued for.</li>
<li>scopes (scp): the scope(s) requested by the client. It shall be possible to issue one token for multiple scopes</li>
<li>token id (jti)</li>
<li>system user ID (uid): the system user ID in which context this token should be considered valid.</li>
<li>issuer (iss): the identity of the vehicle this token was issued for (e.g. the VIN). Services must be able to check that the token was issued for this vehicle to prevent attackers from reusing tokens across vehicles.</li>
<li>public key (sigurl): the url to access the public key used to sign the access token</li>
</ul>
<p><strong>Note</strong> It is left to the client application to decide whether to request a single <code>accessToken</code> with multiple <code>scopes</code> multiple access <code>accessTokens</code> with just a single <code>scope</code> or anything in between, dependeing on client needs. Client developers need to be aware that each <code>accessToken</code> request might throw a dedicated popup.</p>
<h6 id="access-token-signature">Access Token Signature</h6>
<p>The <code>accessToken</code> will be signed with the issuers public certificate. Therefore, the public key of the issuer needs to be accessible by any client during runtime.</p>
<h5 id="api-access">API access</h5>
<p>The client MUST send the <code>accessToken</code> with each request. API access MUST be denied if no token is given or it is found to be invalid for any reason.</p>
<h6 id="access-token-validation">Access Token Validation</h6>
<p>Services MUST be able to perform validation steps for access tokens in isolation, i.e. without having to contact the auth server on every presentation of an access token. Therefore, services shall be able to parse and validate JWT-based access tokens.</p>
<p>The following properties of an access token shall be verified in the following order:</p>
<ul>
<li>Token expiry: A reliable time MUST be available to the service server to check validity/expiration.</li>
<li>Token signature: Services MUST have authenticated access to a public key that can be used to validate token signatures. It must also be possible to update this public key periodically.</li>
<li>Token scope: Services MUST know which scope to expect for a given client request.</li>
<li>Token audience: Services MUST check that the token was issued for the purposes of this protocol.</li>
<li>Token system user ID: The system user ID provided in the token MUST match the current system user known to the service. Services MUST be able to have authenticated access to the current system user ID.</li>
<li>Token issuer: Services MUST be able to check that the token was issued by the auth server in the same vehicle as this service. For one, the issuer identifier MUST match a previously obtained value for this system. Second, the key material used to sign the token must of course also match this vehicle identity.</li>
</ul>
<p>Once these validation steps are completed successfully, the service shall use the token identifier to subscribe to a revocation status for this identifier at the auth server. As long as local validation is successful and no revocation notification is sent by the auth server, the service shall assume that the token is valid. Once a revocation notification is sent, the service shall cache this information for an appropriate amount of time.</p>
<h5 id="token-sequence-overview">Token sequence overview</h5>
<p>The following diagram shows a brief overview of the authorization flow, omitting details like the actual HTTPS calls and WebSocket message syntax.</p>
<p><img src="img/auth.png" alt="Authorization workflow"></p>
<div class="issue">A diagram would be great, if someone wants to draw one.</div>
    </section>
    </section>




    <section data-dfn-for="interface">
      <h2>Interface</h2>
      <p>
        This chapter describes the different methods and its arguments that govern the communication between a <a>service</a> and a <a>client</a>.
      </p>
      <section data-dfn-for="methods">
        <h2>Methods</h2>
        <p>
          A timeout for the response of all methods with responses MUST be defined.
          This timeout is transport protocol specific to reflect the normal behaviour of the transport protocol.
        </p>
        <div class="issue" title="error types for methods">All methods should list the possible error types returned.</div>
        <section data-dfn-for="read">
          <h2><dfn>read</dfn></h2>
          <p>Purpose: obtain a representation of the value addressed by the given path</p>
          <p>The service MUST expose a <a>read</a> method.
             The client MAY use the <a>read</a> method of the service to retrieve values managed by the service. 
             If the service is able to satisfy the request it MUST return a <a>content</a> response.
             If the service is unable to fulfil the request, then the service MUST return an <a>error</a> response.
             The client MAY have to authenticate via the <a>authenticate</a> method before being able to access the values.</p>
          <p>arguments: 
          <ul>
            <li><a>path</a> fully qualified path to a base node</li>
            <li><a>filter</a> selection criterias for specific values under the given <a>path</a></li>
          </ul>
          </p>
          <p>responses:
            <ul>  
              <li><a>content</a> response fulfilling the request</li>
              <li><a>error</a> response describing what went wrong</li>
            </ul>
          </p>
        </section>
        <section data-dfn-for="update">
          <h2><dfn>update</dfn></h2>
          <p>Purpose: providing altered values to the service for a specified <a>path</a></p>
          <p>The service MAY expose an <a>update</a> method.
             The client MAY use the <a>update</a> method of the service to request a change to values managed by the service. 
             If the service is able to satisfy the request it MUST return a <a>change</a> response. 
             If an error occurs the service MUST return an <a>error</a> response.</p>
          <p>arguments: 
            <ul>
              <li><a>path</a> fully qualified path to a base node</li>
              <li><a>filter</a> selection criterias for specific values under the given <a>path</a></li>
              <li><a>change</a> new value that shall be applied</li>
            </ul>
          </p>
          <p>responses:
            <ul>  
              <li><a>change</a> response describing what went well</li>
              <li><a>error</a> response describing what went wrong</li>
            </ul>
          </p>
        </section>
        <section data-dfn-for="create">
          <h2><dfn>create</dfn></h2>
          <p>Purpose: providing new values to the service under a specified <a>path</a></p>
          <p>The service MAY expose a <a>create</a> method.
             The client MAY use the <a>create</a> method of the service to request new values to be managed by the service. 
             If the service is able to satisfy the request it MUST return a <a>change</a> response. 
             If an error occurs the service MUST return an <a>error</a> response.</p>
          <p>arguments: 
            <ul>
              <li><a>path</a> fully qualified path to a base node</li>
              <li><a>change</a> new value that shall be added</li>
            </ul>
          </p>
          <p>responses:
            <ul>  
              <li><a>change</a> response describing what went well</li>
              <li><a>error</a> response describing what went wrong</li>
            </ul>
          </p>
        </section>
        <section data-dfn-for="delete">
          <h2><dfn>delete</dfn></h2>
          <p>Purpose: removing all selected values under a specified <a>path</a></p>
          <p>The service MAY expose a <a>delete</a> method.
             The client MAY use the <a>delete</a> method of the service to request the deletion of existing values managed by the service.
             If the service is able to satisfy the request it MUST return a <a>change</a> response. 
             If an error occurs the service MUST return an <a>error</a> response.</p>
          <p>arguments: 
            <ul>
              <li><a>path</a> fully qualified path to a base node</li>
              <li><a>filter</a> selection criterias for specific values under the given <a>path</a></li>
            </ul>
          </p>
          <p>responses:
            <ul>  
              <li><a>change</a> response describing what went well</li>
              <li><a>error</a> response describing what went wrong</li>
            </ul>
          </p>
        </section>
        <section data-dfn-for="subscribe">
          <h2><dfn>subscribe</dfn></h2>
          <p>Purpose: monitor changes made to values under a specified <a>path</a></p>
          <p>The service MAY expose a <a>subscribe</a> method.
             The client MAY use the <a>subscribe</a> method of the service to request being informed of changes made to values managed by the service.
             The service MUST issue a notification if the equivalent <a>read</a> <a>content</a> response would change.
             If the service is able to satisfy the request it MUST return a <a>subscription</a> and <a>contract</a> response.
             If an error occurs the service MUST return an <a>error</a> response.</p>
          <p>arguments: 
            <ul>
              <li><a>path</a> fully qualified path to a base node</li>
              <li><a>filter</a> selection criterias for specific values under the given <a>path</a></li>
              <li><a>contract</a> describing the expectations for the client receiving notifications</li>
            </ul>
          </p>
          <p>responses:
            <ul>  
              <li><a>subscription</a> response describing the status of the subscription</li>
              <li><a>contract</a> describing the rules for the service sending notifications to the client</li>
              <li><a>error</a> response describing what went wrong</li>
            </ul>
          </p>
        </section>
        <section data-dfn-for="notify">
          <h2><dfn>notify</dfn></h2>
          <p>Purpose: informs of changes made to values under a <a>subscription</a></p>
          <p>The client MUST expose a <a>notify</a> method if it uses the <a>subscribe</a> method of a service.
             The service MUST use the <a>notify</a> method of the client to inform of changes made to values managed by the service under the given <a>subscription</a> by sending a <a>content</a> response.
             The service MUST ignore any response from the client. 
          </p>
          <p>arguments: 
            <ul>
              <li><a>subscription</a> identifying the subscription</li>
              <li><a>content</a> response fulfilling the request</li>
            </ul>
          </p>
          <p>responses: none</p>
        </section>
        <section data-dfn-for="unsubscribe">
          <h2><dfn>unsubscribe</dfn></h2>
          <p>Purpose: stop monitoring the changes made to values under a <a>subscription</a></p>
          <p>The service MUST expose a <a>unsubscribe</a> method if an <a>subscribe</a> method is exposed.
             The client MAY use the <a>unsubscribe</a> method of the service to cancel being informed of changes made to values managed by the service under the given <a>subscription</a>.
             The service MUST stop issuing notifications.
             If the service is able to satisfy the request it MUST return a <a>subscription</a> response.
             If an error occurs the service MUST return an <a>error</a> response.</p>
          <p>arguments: 
            <ul>
              <li><a>subscription</a> identifying the subscription</li>
            </ul>
          </p>
          <p>responses:
            <ul>  
              <li><a>subscription</a> response describing the status of the subscription</li>
              <li><a>error</a> response describing what went wrong</li>
            </ul>
          </p>
        </section>
      </section>
      <section data-dfn-for="arguments-and-responses">
        <h2>Arguments and Responses</h2>
        <section data-dfn-for="content-response">
          <h2><dfn>content</dfn></h2>
          <ul>  
            <li>Value: One or more values associated with the addressed VSS leaves.</li>
            <li>Timestamp: A timestamp associated with the request.</li>
          </ul>  
        </section>
        <section data-dfn-for="filter">
          <h2><dfn>filter</dfn></h2>
          criterias to filter according to a query
        </section>
        <section data-dfn-for="path">
          <h2><dfn>path</dfn></h2>
          see addressing
        </section>
        <section data-dfn-for="change">
          <h2><dfn>change</dfn></h2>
          <ul>
            <li>changed applied immediately or later</li>
            <li>list changed paths</li>
          </ul>  
        </section>
        <section data-dfn-for="subscription">
          <h2><dfn>subscription</dfn></h2>
          status of the subscription
        </section>
        <section data-dfn-for="contract">
          <h2><dfn>contract</dfn></h2>
          describing the rules for subscriptions/notifications
        </section>
        <section data-dfn-for="error">
        <h2><dfn>error</dfn></h2>
          <p>
            An <a>error</a> response MUST include the formal error type.
            An <a>error</a> response MAY include a textual form of the error type. 
            An <a>error</a> response MUST include an error value if obligatory for the error type.
            An <a>error</a> response MUST include a timestamp.
            An <a>error</a> response MUST be actionable.
            <table class="def">
              <tr>
                <th>field</th><th>obligation</th><th>description</th><th>format</th><th>example</th></tr>
              <tr>
                <th>error type</th>
                <td>mandatory</td>
                <td>short handle describing the error.</td>
                <td>protocol specifc</td>
                <td>AuthorizationFailed</td>
              </tr>
              <tr>
                <th>error description</th>
                <td>optional</td>
                <td>Information describing the error reason.</td>
                <td><code>^[\w ]{5,255}$</code></td>
                <td>
                  Authorization failed for the method. 
                  Please set a valid AuthToken and AuthType.
                </td>
              </tr>
              <tr>
                <th>error value</th>
                <td>conditional</td>
                <td>
                  Send if set as mandatory for the error type. 
                  Describing more details to understand the error type.
                </td>
                <td>string, error type specific</td>
                <td>AuthToken valid; Access Level not sufficient.</td>
              </tr>
              <tr>
                <th>timestamp</th>
                <td>mandatory</td>
                <td>The time when the error occured.</td>
                <td><a>date-time</a> compliant</td>
                <td>2005-11-12T12:01:42.123+01:00</td>
              </tr>
            </table>
            <div class="issue" title="error value">Do we really need an error value as all method calls are directly mapped to error response.</div>
            <div class="issue" title="timestamps">How do we want to handle timestamps? Is this something that is signaled through the meta-data for the call of the method? Is this something every method must have?</div>
          </p>
          <section data-dfn-for="error-types">
            <h3>Error Types</h3>
            <p>
              These error types MUST be implemented by a <a>service</a>.
              A transport protocol MAY define additional error types.
              A transport protocol MUST not alter these error types.
            </p>
            <table class="def">
              <tr><th>error type</th><th>Textual description</th><th>values</th><th>Solution/Action</th></tr>
              <tr>
                <th>InvalidToken</th>
                <td>The AuthToken is not recognized as valid.</td>
                <td>none</td>
                <td>Check if AuthType is set correctly. Get a new AuthToken.</td>
              </tr>
              <tr>
                <th>AccessLevelNotSufficient</th>
                <td>The AuthToken is recognized but does not allow the execution of the requested method.</td>
                <td>none</td>
                <td>Get a token with a different access level.</td>
              </tr>
              <tr>
                <th>InvalidPath</th>
                <td>The given path is not valid.</td>
                <td>none</td>
                <td>Check the path given in the arguments.</td>
              </tr>
              <tr>
                <th>MissingArgument</th>
                <td>An mandatory argument is missing from the method execution.</td>
                <td>Missing Argument</td>
                <td>Add missing argument.</td>
              </tr>
              <tr>
                <th>InvalidFilter</th>
                <td>Filter could not be parsed.</td>
                <td>Error Position</td>
                <td>Fix filter.</td>
              </tr>
              <tr>
                <th>ValueNotPermited</th>
                <td>A value set by the client is not permited.</td>
                <td>value</td>
                <td>Set the value to a value permited by the service implementation.</td>
              </tr>
              <tr>
                <th>ContractInvalid</th>
                <td>The contract submitted is not valid.</td>
                <td>Invalid contract statement</td>
                <td>Recall method with a valid contract.</td>
              </tr>
              <tr>
                <th>SubscriptionUnknown</th>
                <td>The subscription is not known by the service.</td>
                <td>none</td>
                <td>Check subscription.</td>
              </tr>
              <tr>
                <th></th>
                <td></td>
                <td></td>
                <td></td>
              </tr>
            </table>
            <div class="issue" title="error type examples">Would examples for the error types be helpful?</div>
            <div class="issue" title="error type location">Where best to describe error types?</div>
          </section>
        </section>
        
      </section>
      <section data-dfn-for="headers">
        <h3>Meta-Data</h3>
        <div class="issue" title="naming: headers/meta-data">
          The title for this chapter is not good.
        </div>
        <p>
          For the communication between service and client several key/value pairs can be given to describe the environment in what the methods (<a href="#methods"></a>) are called.
          The string describing the key MUST be the same structure as <a>name</a>.
        </p>
        
        <section data-dfn-for="authorization">
          <h4><dfn>authorization</dfn></h4>
          <p>Purpose: <a>authorization</a> makes it possible for a client to authorize itself towards a service.</p>
          <p>
            The <a>authorization</a> key/value pairs consists out of a <a>AuthType</a> and a <a>AuthToken</a> key/value pair.
            The client MAY use the <a>authorization</a> key/value pairs to transfer an authorization token to the service.
            The client MUST use either both key/value pairs or none of the two.
            The service MAY use the token transfered by the <a>AuthToken</a> key/value pair to authenticate the client.
            The client MUST set the type of the token with the <a>AuthType</a> key/value pair if <a>AuthToken</a> is set.
            This concept MAY be used for access control.
            A rejected authorization token MUST result in an <a>error</a> response.
            If the execution of a method on a service needs authorization the service MUST use the authorization key/value pair.
            <table class="def">
              <tr><th>key</th>    <td><dfn>AuthToken</dfn></td></tr>
              <tr><th>value</th>  <td><code>^\w{1,1024}$</code></td></tr>
            </table>
            <div class="issue" title="max length AuthToken">How long should the maximum length of a token be to be easily implemented by most protocols.</div>
            <table class="def">
              <tr><th>key</th>    <td><dfn>AuthType</dfn></td></tr>
              <tr><th>value</th>  <td><a>name</a> compliant</td></tr>
            </table>
          </p>
        </section>
        
        <section id="variant-selection">
          <h4>variant selection</h4>
          <p>
            Purpose: 
            A client can express which schema variants it can support when executing a method.
            A service can express which schema variant it uses when communicating with the client.
          </p>
          <p>
            The client MAY set multiple key/value pairs to describe all variants it supports.
            The client MAY not set any key/value pair.
            The service MUST set exactly one schema key/value pair to describe the used variant.
            The client MAY use the [[SemVer]] style to describe degrees of freedom in the version of the schema.
            <table class="def">
              <tr><th>key</th>    <td>Schema</td></tr>
              <tr><th>value</th>  <td><a>schema</a> compliant</td></tr>
              <tr><th>example</th><td>w3c.vehicle.v1.5.3</td></tr>
            </table>
          </p>
        </section>
        
      </section>
    </section>

    <section id="issue-summary" class="appendix"></section>
    <section id="tof" class="appendix"></section>
  </body>
</html>
